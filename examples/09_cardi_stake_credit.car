protocol CardiStakeCredit {
  version: "1.0.0";
  owner: "doge1owner...";

  state {
    blocks_per_day: int = 1440;
    staker_count: int = 0;
    last_settle_idx: int = 0;
    staked_placeholder: string;
    credits_blocks_placeholder: string;
    last_block_placeholder: string;
    is_staker_placeholder: string;
    staker_index_placeholder: string;
  }

  method settle(user: address, current_block: int) {
    _last = state.last_block[user];
    if _last == 0 {
      state.last_block[user] = current_block
    } else {
      _delta = current_block - _last;
      if _delta > 0 {
        state.credits_blocks[user] = state.credits_blocks[user] + state.staked[user] * _delta;
        state.last_block[user] = current_block;
      }
    }
  }
  returns: string "OK";

  method settle_next(current_block: int) {
    if state.staker_count == 0 { returns: string "NoStaker"; }
    idx = state.last_settle_idx;
    if idx > state.staker_count { idx = 0; }
    if idx == state.staker_count { idx = 0; }
    _addr = state.staker_index[idx];
    _last3 = state.last_block[_addr];
    if _last3 == 0 {
      state.last_block[_addr] = current_block
    } else {
      _delta3 = current_block - _last3;
      if _delta3 > 0 {
        state.credits_blocks[_addr] = state.credits_blocks[_addr] + state.staked[_addr] * _delta3;
        state.last_block[_addr] = current_block;
      }
    }
    state.last_settle_idx = idx + 1;
  }
  returns: string "OK";

  method stake(amount: int, current_block: int) {
    if amount <= 0 { returns: string "InvalidAmount"; }

    _last = state.last_block[ctx.sender];
    if _last == 0 {
      state.last_block[ctx.sender] = current_block
    } else {
      _delta = current_block - _last;
      if _delta > 0 {
        state.credits_blocks[ctx.sender] = state.credits_blocks[ctx.sender] + state.staked[ctx.sender] * _delta;
        state.last_block[ctx.sender] = current_block;
      }
    }

    state.staked[ctx.sender] = state.staked[ctx.sender] + amount;

    if state.is_staker[ctx.sender] == 0 {
      state.is_staker[ctx.sender] = 1;
      state.staker_index[state.staker_count] = ctx.sender;
      state.staker_count = state.staker_count + 1;
    }
  }
  returns: string "OK";

  method unstake(amount: int, current_block: int) {
    if amount <= 0 { returns: string "InvalidAmount"; }

    _last2 = state.last_block[ctx.sender];
    if _last2 == 0 {
      state.last_block[ctx.sender] = current_block
    } else {
      _delta2 = current_block - _last2;
      if _delta2 > 0 {
        state.credits_blocks[ctx.sender] = state.credits_blocks[ctx.sender] + state.staked[ctx.sender] * _delta2;
        state.last_block[ctx.sender] = current_block;
      }
    }

    if state.staked[ctx.sender] < amount { returns: string "InsufficientStake"; }
    state.staked[ctx.sender] = state.staked[ctx.sender] - amount;
  }
  returns: string "OK";

  method score_blocks_of(user: address, current_block: int) {}
  returns: int state.credits_blocks[user] + state.staked[user] * (current_block - state.last_block[user]);

  method score_of(user: address, current_block: int) {}
  returns: int (state.credits_blocks[user] + state.staked[user] * (current_block - state.last_block[user])) / state.blocks_per_day;

  method staked_of(user: address) {}
  returns: int state.staked[user];

  method staker_count() {}
  returns: int state.staker_count;

  method staker_at(idx: int) {}
  returns: string state.staker_index[idx];
}


