#include "dogecoin_deployer.h"
#include "carc_generator.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <openssl/sha.h>

namespace cardity {

DogecoinTransaction DogecoinDeployer::create_deployment_transaction(
    const std::string& carc_file,
    const std::string& address,
    const std::string& private_key,
    uint64_t amount) {
    
    DogecoinTransaction tx;
    tx.address = address;
    tx.private_key = private_key;
    tx.amount = amount;
    
    // 读取 .carc 文件
    std::vector<uint8_t> carc_data = read_carc_file(carc_file);
    
    // 生成 OP_RETURN 数据
    tx.op_return_data = generate_op_return_data(carc_data);
    
    // 生成铭文数据
    tx.inscription_data = generate_inscription_data(carc_data);
    
    return tx;
}

std::string DogecoinDeployer::generate_op_return_data(const std::vector<uint8_t>& carc_data) {
    // OP_RETURN 格式: OP_RETURN + 数据长度 + 数据
    std::string op_return = "6a"; // OP_RETURN
    
    // 添加数据长度（十六进制）
    std::stringstream ss;
    ss << std::hex << std::setw(2) << std::setfill('0') << carc_data.size();
    op_return += ss.str();
    
    // 添加数据（十六进制）
    for (uint8_t byte : carc_data) {
        ss.str("");
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
        op_return += ss.str();
    }
    
    return op_return;
}

std::string DogecoinDeployer::generate_inscription_data(const std::vector<uint8_t>& carc_data) {
    // 铭文格式: ordinals 协议格式
    std::string inscription = "ord";
    
    // 添加内容类型
    inscription += "\x01"; // 长度前缀
    inscription += "application/octet-stream";
    
    // 添加数据
    inscription += "\x01"; // 长度前缀
    inscription.append(reinterpret_cast<const char*>(carc_data.data()), carc_data.size());
    
    return inscription;
}

DogecoinTransaction DogecoinDeployer::create_inscription_transaction(
    const std::string& carc_file,
    const std::string& address,
    const std::string& private_key,
    const std::string& content_type) {
    
    DogecoinTransaction tx;
    tx.address = address;
    tx.private_key = private_key;
    tx.amount = 1000; // 铭文需要 dust 限制
    
    // 读取 .carc 文件
    std::vector<uint8_t> carc_data = read_carc_file(carc_file);
    
    // 创建铭文头部
    std::string header = create_inscription_header(content_type);
    
    // 组合铭文数据
    std::vector<uint8_t> inscription_data;
    inscription_data.insert(inscription_data.end(), header.begin(), header.end());
    inscription_data.insert(inscription_data.end(), carc_data.begin(), carc_data.end());
    
    tx.inscription_data = base64_encode(inscription_data);
    
    return tx;
}

bool DogecoinDeployer::validate_carc_file(const std::string& carc_file) {
    try {
        std::ifstream file(carc_file, std::ios::binary);
        if (!file.is_open()) {
            return false;
        }
        
        // 读取头部
        uint32_t magic;
        file.read(reinterpret_cast<char*>(&magic), sizeof(magic));
        
        return magic == 0x43415243; // "CARC"
        
    } catch (...) {
        return false;
    }
}

json DogecoinDeployer::get_carc_info(const std::string& carc_file) {
    json info;
    
    try {
        // 解析 .carc 文件
        Protocol protocol = CarcGenerator::parse_from_carc(carc_file);
        
        info["protocol"] = protocol.name;
        info["version"] = protocol.metadata.version;
        info["owner"] = protocol.metadata.owner;
        info["state_variables"] = protocol.state.variables.size();
        info["methods"] = protocol.methods.size();
        
        // 文件信息
        std::ifstream file(carc_file, std::ios::binary | std::ios::ate);
        if (file.is_open()) {
            info["file_size"] = static_cast<int64_t>(file.tellg());
            file.close();
        }
        
        // 计算哈希
        std::vector<uint8_t> carc_data = read_carc_file(carc_file);
        info["hash"] = calculate_file_hash(carc_data);
        
    } catch (const std::exception& e) {
        info["error"] = e.what();
    }
    
    return info;
}

std::string DogecoinDeployer::generate_deployment_script(const DogecoinTransaction& tx) {
    std::stringstream script;
    
    script << "#!/bin/bash\n";
    script << "# Dogecoin Protocol Deployment Script\n";
    script << "# Generated by Cardity Core\n\n";
    
    script << "ADDRESS=\"" << tx.address << "\"\n";
    script << "PRIVATE_KEY=\"" << tx.private_key << "\"\n";
    script << "AMOUNT=" << tx.amount << "\n\n";
    
    script << "# OP_RETURN 数据\n";
    script << "OP_RETURN_DATA=\"" << tx.op_return_data << "\"\n\n";
    
    script << "# 创建原始交易\n";
    script << "dogecoin-cli createrawtransaction \\\n";
    script << "  '[{\"txid\":\"<input_txid>\",\"vout\":0}]' \\\n";
    script << "  '[{\"data\":\"$OP_RETURN_DATA\"},{\"$ADDRESS\":$AMOUNT}]'\n\n";
    
    script << "# 签名交易\n";
    script << "dogecoin-cli signrawtransaction <raw_tx> '[{\"txid\":\"<input_txid>\",\"vout\":0,\"scriptPubKey\":\"<script_pubkey>\",\"redeemScript\":\"\"}]' '[\"$PRIVATE_KEY\"]'\n\n";
    
    script << "# 发送交易\n";
    script << "dogecoin-cli sendrawtransaction <signed_tx>\n";
    
    return script.str();
}

json DogecoinDeployer::generate_rpc_commands(const DogecoinTransaction& tx) {
    json commands;
    
    // 创建原始交易命令
    json create_tx;
    create_tx["method"] = "createrawtransaction";
    create_tx["params"] = {
        {{{"txid", "<input_txid>"}, {"vout", 0}}},
        {{{"data", tx.op_return_data}}, {{tx.address, tx.amount}}}
    };
    commands["create_transaction"] = create_tx;
    
    // 签名交易命令
    json sign_tx;
    sign_tx["method"] = "signrawtransaction";
    sign_tx["params"] = {
        "<raw_tx>",
        {{{"txid", "<input_txid>"}, {"vout", 0}, {"scriptPubKey", "<script_pubkey>"}, {"redeemScript", ""}}},
        {tx.private_key}
    };
    commands["sign_transaction"] = sign_tx;
    
    // 发送交易命令
    json send_tx;
    send_tx["method"] = "sendrawtransaction";
    send_tx["params"] = {"<signed_tx>"};
    commands["send_transaction"] = send_tx;
    
    return commands;
}

std::vector<uint8_t> DogecoinDeployer::read_carc_file(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open file: " + filename);
    }
    
    file.seekg(0, std::ios::end);
    size_t file_size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<uint8_t> data(file_size);
    file.read(reinterpret_cast<char*>(data.data()), file_size);
    file.close();
    
    return data;
}

std::string DogecoinDeployer::calculate_file_hash(const std::vector<uint8_t>& data) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, data.data(), data.size());
    SHA256_Final(hash, &sha256);
    
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    
    return ss.str();
}

std::string DogecoinDeployer::base64_encode(const std::vector<uint8_t>& data) {
    const std::string base64_chars = 
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";
    
    std::string result;
    int val = 0, valb = -6;
    
    for (uint8_t c : data) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            result.push_back(base64_chars[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    
    if (valb > -6) {
        result.push_back(base64_chars[((val << 8) >> (valb + 8)) & 0x3F]);
    }
    
    while (result.size() % 4) {
        result.push_back('=');
    }
    
    return result;
}

std::string DogecoinDeployer::create_inscription_header(const std::string& content_type) {
    std::string header = "ord";
    header += "\x01"; // 长度前缀
    header += content_type;
    header += "\x00"; // 数据分隔符
    return header;
}

} // namespace cardity 